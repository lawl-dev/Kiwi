using <namespaceName>

namespace <namespaceName>
{
}

descriptor <DescriptorName>
{
	func <FunctionName>([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>]) [-> <returnType> | <dataClassDeclaration>];
}

//Class
class <ClassName> [is <DescriptorName>]
{
	Constructor([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>])
	{
		[<statements>]
	}

	[<const / var>] <fieldName> : <expression>
	
	func <FunctionName>([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>]) [-> <returnType> | return <expression>]
	[{
		[<statements>]
	}]
	
	//op overload
	func >(<ClassName> opB) -> return this.length > opB.length
	func :+(<ClassName> opB)
	{
		[some code]
	}	
	static func +(<ClassName> opA, <ClassName> opB) -> return new <ClassName>([some code])
}


[return <value> | (<value1>, <valueN>)/*dataClassDeclaration constructor call*/ ]
new <ClassName>(<paramerter>);

enum <EnumName>
{
	<ValueName1> [ : <Value1>],
	<ValueNameN>
}

when [(<ExpressionOrValue>) ]{
    case is <TypeName>		-> {...}
    case !<value> 	 		-> ...
    case in <value1>, <valueN>  -> ...
    case !in <value1>, <valueN>  -> ...
	case <operator> <value>  -> ...
    else     			-> ...
}

var foo : when [(<ExpressionOrValue>) ]
			{
				case is <TypeName>		-> <expression>
				case !<value> 	 		-> <expression>
				case in <value1>, <valueN>  -> <expression>
				case !in <value1>, <valueN>  -> <expression>
				case <operator> <value>  -> <expression>
				else     			-> <expression>
			}
			

switch(<expression>) {
	case <const1> ->{...}
	case <const2> ->...
	case <constN> ->...
	else       ->...
}

var foo : switch(<expression>) 
		  {
				case <const1> -> <expression>
				case <const2> -> <expression>
				case <constN> -> <expression>
				else       -> <expression>
		  }

		  
var d : none int


var a;
var b;
var c = func(a, b) -> return a * b;

range:
<valueFrom>..<valueTo>

VariableDdeclaration:
var <variableName> : <expression>

Assignment:
<variableName> : | :+ | :- ... <expression>

for([var] <singleItem> in <collection>)
{
	<statements>
}

forr(<singleItem> in <collection>)
{
	<statements>
}

for([var] <variableInit>; <expesssion>; <exoression>)
{
	<statements>
}


try
{
	<statements>
}
catch
{
	
}

Operators:
Add: +
Sub: -
Mult: *
Div: /
Pow: ^



Aktuelle Probleme:
4. 
Descriptor support
5.
Vererbung 
6. 
Generic 
	