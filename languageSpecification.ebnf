using <namespaceName>

namespace <namespaceName>
{
}

//Descriptor
descriptor <DescriptorName>
{
	func <FunctionName>([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>]) [-> <returnType> | <dataClassDeclaration>];
}

//Class
class <ClassName> [is <DescriptorName>]
{
	Constructor([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>])
	{
		[<statements>]
	}

	[<const / var>] <fieldType> <fieldName> [ = <expression> ]
	
	func <FunctionName>([<parameterType> <parameterName>, ..<paramsParameterType> <parameterName>]) [-> <returnType> | <dataClassDeclaration> | return <expression>]
	[{
		[<statements>]
	}]
}


[return <value> | (<value1>, <valueN>)/*dataClassDeclaration constructor call*/ ]
new <ClassName>(<paramerter>);

enum <EnumName>
{
	<ValueName1> [ : <Value1>],
	<ValueNameN>
}

when [(<ExpressionOrValue>) ]{
    is <TypeName>		-> {...}
    !<value> 	 		-> ...
    in <value1>, <valueN>  -> ...
    !in <value1>, <valueN>  -> ...
	<operator> <value>  -> ...
    else     			-> ...
}

var foo : when [(<ExpressionOrValue>) ]
			{
				is <TypeName>		-> <expression>
				!<value> 	 		-> <expression>
				in <value1>, <valueN>  -> <expression>
				!in <value1>, <valueN>  -> <expression>
				<operator> <value>  -> <expression>
				else     			-> <expression>
			}
			

switch(<expression>) {
	case <const1> ->{...}
	case <const2> ->...
	case <constN> ->...
	else       ->...
}

var foo : switch(<expression>) 
		  {
				case <const1> -> <expression>
				case <const2> -> <expression>
				case <constN> -> <expression>
				else       -> <expression>
		  }
			
range:
<valueFrom>..<valueTo>

VariableDdeclaration:
var <variableName>

VariableInit:
<variableName> : <expression>

for(<singleItem> in <collection>)
{
	<statements>
}

forr(<singleItem> in <collection>)
{
	<statements>
}

for(<variableInit>; <expesssion>; <exoression>)
{
	<statements>
}

Operators:
Add: +
Sub: -
Mult: *
Div: /
Pow: ^
